<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8">
  <title>Prezentare Sistem - Warehouse AI</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body, html {
      height: 100%;
      font-family: 'Segoe UI', sans-serif;
      color: white;
      overflow-x: hidden;
    }
    #bg-canvas {
      position: fixed;
      z-index: -1;
      top: 0;
      left: 0;
    }
    nav {
      width: 100%;
      padding: 15px 40px;
      background-color: rgba(0,0,0,0.7);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    nav h1 {
      font-size: 1.6rem;
      color: #4CAF50;
    }
    .nav-buttons a {
      margin-left: 20px;
      text-decoration: none;
      color: white;
      font-weight: bold;
      background: #4CAF50;
      padding: 8px 16px;
      border-radius: 4px;
      transition: 0.3s;
    }
    .nav-buttons a:hover {
      background: #43a047;
    }
    .hero {
      text-align: center;
      padding: 100px 20px 40px;
      background: rgba(0,0,0,0.5);
    }
    .hero h2 {
      font-size: 2.5rem;
      margin-bottom: 20px;
    }
    .hero p {
      font-size: 1.2rem;
      max-width: 800px;
      margin: 0 auto;
    }
    .section {
      max-width: 1000px;
      margin: 60px auto;
      padding: 20px;
      background-color: rgba(30,30,30,0.8);
      border-radius: 10px;
    }
    .section h3 {
      color: #4CAF50;
      margin-bottom: 10px;
    }
    .section p {
      line-height: 1.7;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <canvas id="bg-canvas"></canvas>

  <nav>
    <h1>Warehouse Hub</h1>
    <div class="nav-buttons">
      <a href="index.php">Home</a>
      <a href="php/logout.php">Logout</a>
    </div>
  </nav>

  <div class="hero">
    <h2>Simulare RoboÈ›i Autonomi Ã®n Depozit</h2>
    <p>Un sistem inteligent de livrare a coletelor Ã®ntr-un mediu de tip depozit, cu algoritmi de evitare a coliziunilor È™i colaborare Ã®ntre roboÈ›i.</p>
  </div>

  <div class="section">
    <h3>ğŸ” Algoritmul de Hivemind</h3>
    <p>Fiecare robot este conÈ™tient de poziÈ›ia È™i starea celorlalÈ›i roboÈ›i, pÄƒstrÃ¢nd o memorie colectivÄƒ sincronizatÄƒ Ã®n timp real. Nu existÄƒ un server central sau un lider, ci fiecare robot Ã®È™i construieÈ™te propriile decizii Ã®n funcÈ›ie de ce "vede" Ã®n sistem. DacÄƒ un robot identificÄƒ un potenÈ›ial blocaj sau conflict pe traseu, va replanifica imediat ruta sa Ã®n mod autonom, asigurÃ¢nd astfel o fluiditate a livrÄƒrilor fÄƒrÄƒ coliziuni.</p>

    <h3>â­ Algoritmul A* Pathfinding</h3>
    <p>Planificarea traseelor se realizeazÄƒ cu algoritmul A* (A star), cunoscut pentru eficienÈ›a È™i acurateÈ›ea sa. Acesta calculeazÄƒ drumul cel mai scurt pÃ¢nÄƒ la È›intÄƒ, luÃ¢nd Ã®n considerare:

        Costul deja parcurs (g)
        DistanÈ›a estimatÄƒ pÃ¢nÄƒ la destinaÈ›ie (h, adesea cu formula Manhattan)
        Scorul final f = g + h pentru prioritizare
        Fiecare nod analizat este evaluat È™i comparat, iar cele deja vizitate sunt excluse pentru a evita ciclurile sau buclele infinite.</p>

    <h3>â³ Sincronizare È™i evitare</h3>
    <p></p>RoboÈ›ii sunt animaÈ›i fluid cu ajutorul interpolÄƒrii liniare (lerp), pentru o miÈ™care naturalÄƒ. Ãn fiecare cadru de simulare, un robot verificÄƒ dacÄƒ urmÄƒtoarea poziÈ›ie este ocupatÄƒ sau nu. DacÄƒ da, acesta se opreÈ™te sau regenereazÄƒ drumul. Astfel, roboÈ›ii nu doar cÄƒ evitÄƒ coliziunile, ci È™i Ã®nvaÈ›Äƒ Ã®n timp cum sÄƒ Ã®È™i sincronizeze traiectoriile pentru o eficienÈ›Äƒ maximÄƒ. </p>
  </div>

  <script>
    let dots = [];

    class Dot {
      constructor() {
        this.x = random(window.innerWidth);
        this.y = random(window.innerHeight);
        this.size = 4;
        this.speed = 1.5;
        this.dir = random([0, 90, 180, 270]); // sus, dreapta, jos, stÃ¢nga
      }

      update() {
        let angle = radians(this.dir);
        this.x += cos(angle) * this.speed;
        this.y += sin(angle) * this.speed;

        if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
          this.dir = (this.dir + 180) % 360;
        }

        for (let other of dots) {
          if (other !== this && dist(this.x, this.y, other.x, other.y) < 10) {
            this.dir = (this.dir + random([90, 180, 270])) % 360;
          }
        }
      }

      draw() {
        noStroke();
        fill(76, 175, 80, 150);
        circle(this.x, this.y, this.size);
      }
    }

    function setup() {
      let c = createCanvas(window.innerWidth, window.innerHeight);
      c.id("bg-canvas");
      for (let i = 0; i < 60; i++) {
        dots.push(new Dot());
      }
    }

    function draw() {
      background(18, 20, 23, 50);
      for (let d of dots) {
        d.update();
        d.draw();
      }
    }

    function windowResized() {
      resizeCanvas(window.innerWidth, window.innerHeight);
    }
  </script>
</body>
</html>
